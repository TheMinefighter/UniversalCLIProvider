\documentclass[a4paper,11pt,titlepage,ngerman]{article}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage{csquotes}
\usepackage{outlines}
\usepackage[perpage]{footmisc}
%\usepackage{cite}
% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage}
\setkomafont{pageheadfoot}{\textrm}
\ifoot{Tobias Brohl}
\cfoot{\thepage}
\ohead{}
% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}
\usepackage{float}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\bibliography{Biblio}
\addbibresource{Biblio.bib}
\usepackage[nottoc,numbib]{tocbibind}
% Für Quelltext
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{lightgray}{gray}{0.9}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
keywordstyle=\color{blue},commentstyle=\color{mygreen},
stringstyle=\color{mymauve},rulecolor=\color{black},
basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
captionpos=b, % sets the caption-position to bottom
keepspaces=true, % keeps spaces in text
numbers=left, numbersep=5pt,showstringspaces=true,
showtabs=false, stepnumber=2, tabsize=2,
numbers=none,language={[Sharp]C},breaklines=true,frame=single, literate={ö}{{ö}}1
{ä}{{ä}}1
{ü}{{ü}}1
{ß}{{\ss}}1
}

% Diese beiden Pakete müssen als letztes geladen werden
%\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{xurl}
%\usepackage{biber}

% Daten für die Titelseite
\title{Entwicklung einer Bibliothek zum universellen Bereitstellen von Kommandozeilenoberfächen}
\author{Tobias Brohl}
\date{\today \linebreak \linebreak Facharbeit im Fach Informatik (If GK 1)}

\parindent=0pt
\newcommand{\inlinecode}[1]{{\lstinline[language=]$#1$}}
\begin{document}
 \begin{sloppypar}
  \maketitle
  \setcounter{tocdepth}{5}
  \setcounter{page}{0}
  \thispagestyle{empty}
  \tableofcontents
  \pagebreak
  %\section{Grundlagen\& Vorgehen} Verwandte Arbeiten;Validierung;Limitierungen
  \section{Einleitung \& Motivation}\label{sec:Intro}
  In dieser Arbeit geht es um die Entwicklung einer Bibliothek, welche Unabhängig von der konkreten Verwendung Kommandozeilenoberflächen bereitstellen kann, für C\#.
  Die Motivation für dieses Projekt ist die Erfahrung bei einem anderen das es keine meinen speziellen Anforderungen entsprechende Bibliothek gab, so dass ich die Idee hatte selbst eine alternative zu entwickeln.
  \section{Vergangenheit, Typen \& Probleme von Kommandozeilenoberflächen}
  \subsection{Differenzierung verschiedener Typen Kommandozeilenoberflächen}\label{subsec:DifferentCLITypes}
  \subsubsection{Windows typische Kommandozeilenoberflächen}
  Typisch für Windows Kommandozeilenoberflächen ist es ein \inlinecode{/} vor Paramternamen, manchmal auch vor Subkommmando-Namen, verwendet wird, wobei oft auch die Verwendung von \inlinecode{-} korrekt erkannt wird.
  Au\ss erdem werden im Windows Bereich oft sehr viele Funktionen, die z.T. nicht viel miteinander zu tun haben, in ein Befehl gelegt, welches dann viele Subkommandos besitzt.
  \subsubsection{*nix typische Kommandozeilenoberflächen}
  *nix\footnote{*nix wird als Sammelbegriff für Unix und Unix basierte Systeme, wie Linux, MacOS oder OpenBSD, verwendet} typische Kommandozeilenoberflächen
  zeichenen sich dadurch aus das sie statt des \inlinecode{/}, welches zu mehrdeutigkeiten führen könnte, da in *nix systemen Pfade mit Schrägstrichen beginnen, vor Parametern \inlinecode{--} verwenden.
  Häufig benötigte Parameter haben haben meist ein Kurzformen Form eines einzelnen Buchstaben / Zeichen, welcher hinter einem \inlinecode{-} angegeben wird.
  Viele Kommandozeilenoberflächen erlauben auch die aneinander Reihung solcher Kurzformen:
  Wenn z.B. \inlinecode{-a} und \inlinecode{-m} Parameter Kurzformen sind, kann \inlinecode{-am} als Kurzform für beide Optionen verwendet werden.
  Dabei muss \inlinecode{-a} ein Flag\footnote{Als Flag werden Parameter bezeichnet, die keinen weiteren Wert benötigen sondern ein boolean aktivieren} sein,
  \inlinecode{-m} kann auch ein Wertparamter sein dessen Wert dann dahinter stehen müsste.

  Eine weitere Eigenschaft, die typisch für Kommandozeilenoberflächen im *nix Berreich ist, ist dass,
  im Vergleich zu Windows Kommandozeilenoberflächen mehr getrennte Befehle mit weniger Subkommandos verwendet werden.
  \subsubsection{Ineraktive Kommandozeilenoberflächen}
  Mit der veröffentlichung von Windows XP Professional im Jahr 2000, wurde die Windows Management Instrumentation (WMI),
  zusammen mit der dafür vorgesehenen Windows Management Instrumentation Command-line (WMIC) eingeführt~\cite{WMIProgrammingBlogPost}.
  In dieser hat das Konzept einer interaktiven Shell zum aufrufen von
  Programmfunktionen~\footnote{Für SSH, TELNET und interaktive Compiler kamen interaktive Kommandozeilenoberflächen auch schon früher zum Einsatz} erstmals zum Einsatz.
  Diese interactive Shell kann mit dem \inlinecode{wmic} Befehl aufgerufen werden, dann kann man Einstellungen definieren wie
  z.B. die Sprache mit \inlinecode{/LOCALE} definieren die bis zum beenden der interaktiven Shell verwendet werden.

  Eine weiterer wichtiger Meilenstein für interakive Shells ist die 2005 von Facebook Inc. veröffentlichte Bibliothek Nubia~\cite{NubiaReleaseBlogPost} für Python.
  \begin{figure}[H]
	\includegraphics[width=\linewidth]{PythonNubia.png}
	\caption{Ausschnitt aus der offiziellen Demo der Bibliothek}
	\label{fig:PythonNubia}
  \end{figure}
  Sie hat als erstes Syntax-highlighting in einer ineraktiven Kommandozeile eingeführt, zusammen mit einem Autocomplete auf dem Niveau moderner IDEs.
  \subsubsection{Graphische Kommandozeilenbenutzeroberfächen}
  Graphische Kommandozeilenbenutzeroberfächen (GCLUI) werden oft verwendet wenn die Bedienung durch einen Endnutzer passieren soll,
  und nicht dazu genutzt werden soll um von anderen Programmen automatisch aufgerufen werden soll.
  In vielen solchen Fällen würde man dann Grafische Benutzeroberflächen (GUI) nutzen, in Fällen wo die Bedienbarkeit aber auch über SSH u.ä. gewährleistet sein soll werden aber meist GCLUI genutzt.
  Dass prominenteste Beispiel für einen solchen fall ist der \inlinecode{raspi-config} Befehl der die System-Konfiguration von Raspberry Pi's erlaubt.
  %TODO Plural Raspi
  \begin{figure}[H]
	\includegraphics[width=\linewidth]{raspi-config.png}
	\caption{Die raspi-config Oberfläche}
	\label{fig:raspi-config}
  \end{figure}
  Die Navigation ist dort mit den Pfeil- und Zahlentasten, sowie der Tabtaste, möglich und macht die Bedienung sehr einfach und intuitiv~\cite{RaspiConfigOfficialInfo}.
  \subsection{Vergangenheit \& Aktueller Stand der Technik für C\#}\label{subsec:CurrentState}
  \subsubsection{NDesk.Options / Mono.Options Bibliothek}
  Die NDesk.Options Bibliothek wurde zuerst im Januar 2008 angekündigt~\cite{NDeskAnnouncement},
  und noch im gleichen Monat in erster Version veröffentlicht~\cite{NDesk1stRelease}.
  Der Author hat diese als Nachfolger der Mono.GetOptions Bibliothek,
  welche im Dezember 2006 schon existiert~\cite{MonoGetOptions3rdBlogPost} haben muss und dessen Entwicklung spätestens Ende 2007 eingestellt wurde,
  über die jedoch wenige Informationen vorhanden sind.
  Aufgrund dieses frühen Erscheinens ist die Bibliothek auf C\#2 ausgelegt, weswegen von vielen Möglichkeiten neuerer C\# Versionen,
  die die Bedinung einer solchen Bibliothek deutlich einfacher machen würden viele neue Bedienmöglichkeiten mit sich bringen.
  Die Bibliothek erlaubt das definieren von Optionen optional mit mehrere verwendbaren Namen.
  Diese können entweder ein delegate\footnote{Ein delegate in C\# ist ein Referenzdatentyp, der eine Prozedur speichert die mehrere Werte annhemen kann und optional einen Wert zurückgeben kann.} bereitstellen, dass den folgenden Parameter als String verarbeitet,
  oder ein Typ angegeben in den der folgende Parameter durch einen \inlinecode{System.ComponentModel.TypeConverter} umgewandelt wird,
  und dann ein delegate, dass das Parameter in dem vorher angegebenen Typ verarbeitet.
  Des weiteren werden Boolean flags unterstützt die durch \inlinecode{-OptionsName+} aktiviert
  und durch \inlinecode{-OptiosName-} deaktiviert werden können~\cite{NDeskOptionSetDocumentation}.
  Der letzte eigene Release wurde im Oktober 2008 veröffentlicht~\cite{NDeskOptionsLastRelease},
  dann ist die Bibliothek als Mono.Options als Teil des Mono Projekts neuveröffentlicht worden~\cite{MonoOptions1stCommit},
  dass seit 2011 durch Xamarin~Inc. weiterentwickelt wird~\cite{MonoFutureInterview}, welche seit 2016 Teil von Microsoft ist~\cite{MicrosoftBlogAcquireXamarin}.
  Seit dem ist die Popularität der Bibliothek sehr stark gestiegen, sodass es aktuell kanpp 600.000 Downloads auf nuget.org hat~\cite{MonoOptionsNuget}.
  \subsubsection{Command Line Parser Bibliothek}
  Die 2012\footnote{Der Autor selbst schreibt in der readme des Projekts 2005, jedoch habe ich keine Informationen finden können die dies decken, auf eine Anfrage hat der Autor nicht geantwortet} veröffentlichte Bibliothek Command Line Parser~\cite{FirstCommandLineParserCommit}  
  hat als erstes das Konzept von Attribut-definierten Kommandozeilenoberflächen im C\#Bereich.
  Sie wird seit der Veröffentlichung aktiv weiteretwickelt, nutzt die möglichkeiten aktueller C\# Versionen.
  Die Bibliothek stellt eine vollständige Hilfefunktion, baumartige Organistaion von Subkommandos, Parameter, Umfangreiche Typkonvertierungen, sowie Kurzformen bereit~\cite{CommandLineParserWiki}.
  Au\ss erdem stellt die Bibliothek dedizierten F\# Support bereit, der jedoch in dieser Arbeit nicht weiter behandelt werden soll.
  Die Bibliothek ist die am weitesten verbreitetste Lösung im C\# Umfeld mit 6.1 Millionen Downloads auf nuget.org~\cite{CommandLineParserNuget}. 
  \subsection{Bisher ungelöste Probleme}\label{subsec:currentproblems}
  df
  \subsubsection{Sonderzeichen-Unterstützung}
  \subsubsection{Interaktive Konsolen}
  \subsubsection{Konfigurationsdateimanagement}
  \section{Implementation}\label{sec:Content}
  \input{implementation}

  \section{Ausblick}\label{sec:Future}
  Das Projekt ist, wie oben beschrieben schon jetzt sehr umfangreich, es gibt aber noch grö\ss eres Verbesserungspotential, welches ich in diesem Kapitel erl\"autern m\"ochte.
  \subsection{Ausbau der Kernfunktionen}\label{subsec:MoreFunctions}
  \subsection{Übertragbarkeit auf andere Programmiersprachen}\label{subsec:PortabilityToOtherLangs}
  Das Projekt ist in gro\ss en fast Vollständig in C\# ähnliche Sprache, wie Java, übertragbar, da fast alle Sprachen ein Konzept aud Annotationen oder Attributen implementieren 
  \subsection{Geschwindigkeitsverbesserungen durch Speicherung von Reflections}\label{subsec:StoringReflections}
  \subsection{Implementation einer eigenen Auto-Vervollständigung}\label{subsec:Autocomplete}
  Die Implementation einer Auto-Vervollständigung würde der Bibliothek ein weiteres Schlüsselmerkmal gegenüber anderen C\# Bibliotheken geben.
  Wenn dieses Feature aber auch in der Praxis praktisch sein soll, wäre es wichtig weitere Informationen über übergebenen Daten haben.
  So wäre zum Beispiel ein Attribut für Parameter sinnvoll, das es ermöglicht zu definieren, das der Parameter ein Pfad eines Ordners, 
  der existiert, ist, so dass die Auto-Vervollständigung entsprechende Werte vorschlagen kann.
  Nur mit solchen Informationen kann eine Autovervollständigung im Alltäglichen arbeiten mit der Software einen Vorteil schaffen.
  Im folgenden möchte ich auf verschieden Umgebungen für automatische Vervollständigungen eingehen.
  \subsubsection{Auto-Vervollständigung für die Interaktive Kommandozeilenoberfläche}
  Eie Funktion zur automatischen Verfollständigung von Befehlen in der Interaktive Kommandozeilenoberfläche, würde die Verwendung dieser Potentiell deutlich attraktiver machen, 
  da in einer interaktiven Kommandozeilenoberfäche es möglich ist, eine sehr umfangreiche Verfollständigung zu bieten.
  Dabei gibt es viele unterchiedliche Ausführungen, wie z.B. die der o.g. Python-Nubia Bibliothek, alle mit ihren Vor- und Nachteile.
  Eine umfangreiche Evaluation dieser wird der Implementation mindestens einer vorrausgehen. 
  \subsubsection{Auto-Vervollständigung für Linux Kommandozeilen}
  In vielen Linux Umgebungen ist es möglich das Verhalten zur Auto-Vervollständigung in der Systemeigenen Shell anzupassen.
  Dafür muss eine Bash Datei mit vorgegebenen Funktionen vorhanden sein~\cite{BashAutoComplete}.
  In der Zukunft wäre es denkbar, in diese Bibliothek eine Funktion zu implementieren, die es ermöglicht diese Dateien auf Basis der definierten Aktion,
  Kontexte und anderer Eigenschaften vollautomatisch zu generieren.
  \subsubsection{Auto-Vervollständigung für die Windows Powershell}
  Die Windows Powershell hat eine Auto-Vervollständigungs Funktion, aber nur für Powershell Cmdlets.
  Cmdlets bieten selber eine eigene einfache Kommandozeilenoberfläche, diese wird dann automatisch verfollständigt und dessen Eingaben werden automatisch in Objekte verarbeitet~\cite{CustomCmdlet}.
  Daher wäre es dann nötig eine Funktion zu entwickeln, die für ein C\# Programm einen Powerdhell Cmdlet generiert, dass die gleichen möglichen Befehle hat, 
  das dann in der Powershell automatisch Verfollständigt werden kann.
    Ich gehe davon aus das dieser Prozess sehr komplex wäre, und bin mir nicht sicher ob es möglich ist in dieser Umgebung, zum Beispiel für Konfigurationspfade, eine Verfollständigung bereitzustellen.
  \subsection{Verbesserung der Unit test Abdeckung}\label{subsec:MoreUnitTests}
  \section{Anmerkungen}\label{sec:AdditionalNotes}
  \subsection{Umgebungsvorraussetzungen zum nutzen der Bibliothek}\label{subsec:SystemRequirements}
   Die Bibliothek kann unter Windows (ab 7 SP1), Linux (Support hängt von der Distribution ab) und Mac OS X (ab 10.12) verwendet werden
  \footnote{genauere Informationen sind unter https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1-supported-os.md verfügbar}, 
  da Das Projekt .Net Core 2.1 untertsützt.
  Für Windows ist die Verwendung des .NET Framework, ab Version 4.7.2, empfehlenswert, da dann die exe Dateien ohne Probleme verwendet werden können.
  Des weiteren untertützt das Projekt .Net Standard 2.0 und .NET Core 2.0.
  \subsection{Verwendung von weiteren Bibliotheken}\label{subsec:UsageOfLibraries}
  Ich habe folgende Bibliotheken für dieses Projekt verwendet:
  \begin{outline}
   \1 Die \inlinecode{PropertyOrFieldInfo} Bibliothek, die ich selbst vollständig entwickelt und programmiert habe,
   und 2018 unter MIT License veröffentlicht habe~\cite{PropOrFieldSite}, in der Version 1.0.1.
   \1 Die \inlinecode{xunit} Bibliothek habe ich für Unit Tests verwendet, sie wird nicht mit der Bibliothek kompiliert wird.
   Ich habe die Version 2.4.1 verwendet, die 2018 unter MIT License veröffentlicht wurde~\cite{XunitReleaseNotes}.
   \1 Die \inlinecode{Newtonsoft.Json} Bibliothek von James Newton-King, um JSON Inhalte zu verarbeiten, in der Version 12.0.1,
   die 2018 unter MIT License veröffentlicht wurde~\cite{JsonNetSite}.
   \1 Die \inlinecode{Jetbrains.Annotations} Bibliothek, die nicht mit dem Programm kompiliert wird,
   sondern ausschlie\ss lich während der Entwicklung des Programmes aktiv ist, und Funktionen wie Nullf\"ahigkeitsprüfungen bereitstellt.
   Die Version 2018.3.0, die ich verwende, wurde 2019 unter MIT License veröffentlicht~\cite{AnnotationsNuget}.
  \end{outline}
  \section{Fazit}\label{sec:Conclusion}
  \section{Anhang}\label{sec:Attachments}
  Der Anhang entählt folgende Inhalte:
  \begin{outline}
   \1 Der vollständige Quellcode
   \1 Die kompilierte Bibliothek
   \1 Die kompilierte Referenzverwendung
  \end{outline}
  Alle Anhänge werden in digitaler Form auf CD bereitgestellt.
  \section{Literaturverzeichnis}\label{sec:Literature}
  \printbibliography[heading=none]
  \newpage
  \begin{samepage}
	\thispagestyle{empty}
	Hiermit erkläre ich, dass ich die vorliegende Facharbeit selbstständig und ohne fremde Hilfe angefertigt und nur die im Literaturverzeichnis
	aufgeführten Hilfen und Quellen benutzt habe.
	Insbesondere versichere ich, dass ich alle wörtlichen
	und sinngemä\ss en Übernahmen aus anderen Werken als solche kenntlich gemacht habe.
	\medbreak
	Lemgo, den \today
	\medbreak
  \end{samepage}
 \end{sloppypar}
\end{document}
