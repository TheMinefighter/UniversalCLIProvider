 \subsection{Differenzierung verschiedener Typen Kommandozeilenoberflächen}\label{subsec:DifferentCLITypes}
 \subsubsection{*nix typische Kommandozeilenoberflächen}
 \subsubsection{Windows typische Kommandozeilenoberflächen}
 Mit der veröffentlichung von Windows XP Professional im Jahr 2000, wurde die Windows Management Instrumentation (WMI),
 zusammen mit der dafür vorgesehenen Windows Management Instrumentation Command-line (WMIC) eingeführt~\cite{WMIProgrammingBlogPost}.
 In dieser hat das Konzept einer interaktiven Shell zum aufrufen von
 Programmfunktionen~\footnote{F\"ur SSH, TELNET und interaktive Compiler kamen interaktive Kommandozeilenoberfl\"achen auch schon fr\"uher zum Einsatz} erstmals zum Einsatz.
 Diese interactive Shell kann mit dem \inlinecode{wmic} Befehl aufgerufen werden, dann kann man Einstellungen definieren wie
 z.B. die Sprache mit \inlinecode{/LOCALE} definieren die bis zum beenden der interaktiven Shell verwendet werden.
 \subsubsection{Graphische Kommandozeilenbenutzeroberfächen}
 Graphische Kommandozeilenbenutzeroberfächen (GCLUI) werden oft verwendet wenn die Bedienung durch einen Endnutzer passieren soll,
 und nicht dazu genutzt werden soll um von anderen Programmen automatisch aufgerufen werden soll.
 In vielen solchen Fällen würde man dann Grafische Benutzeroberflächen (GUI) nutzen, in Fällen wo die Bedienbarkeit aber auch über SSH u.ä. gewährleistet sein soll werden aber meist GCLUI genutzt.
 Dass prominenteste Beispiel für einen solchen fall ist der \inlinecode{raspi-config} Befehl der die System-Konfiguration von Raspberry Pi's erlaubt.
 %TODO Plural Raspi
 \begin{figure}[H]
\includegraphics[width=\linewidth]{raspi-config.png}
\caption{Die raspi-config Oberfläche}
\label{fig:raspi-config}
 \end{figure}
 Die Navigation ist dort mit den Pfeil- und Zahlentasten, sowie der Tabtaste, möglich und macht die Bedienung sehr einfach und intuitiv~\cite{RaspiConfigOfficialInfo}.
 \subsection{Vergangenheit \& Aktueller Stand der Technik f\"ur C\#}\label{subsec:CurrentState}
 \subsubsection{NDesk.Options / Mono.Options Bibliothek}
 Die NDesk.Options Bibliothek wurde zuerst im Januar 2008 angekündigt~\cite{NDeskAnnouncement},
 und noch im gleichen Monat in erster Version veröffentlicht~\cite{NDesk1stRelease}.
 Der Author hat diese als Nachfolger der Mono.GetOptions Bibliothek,
 welche im Dezember 2006 schon existiert~\cite{MonoGetOptions3rdBlogPost} haben muss und dessen Entwicklung spätestens Ende 2007 eingestellt wurde,
 über die jedoch wenige Informationen vorhanden sind.
 Aufgrund dieses frühen Erscheinens ist die Bibliothek auf C\#2 ausgelegt, weswegen von vielen Möglichkeiten neuerer C\# Versionen,
 die die Bedinung einer solchen Bibliothek deutlich einfacher machen würden viele neue Bedienmöglichkeiten mit sich bringen.
 Die Bibliothek erlaubt das definieren von Optionen optional mit mehrere verwendbaren Namen.
 Diese können entweder ein delegate bereitstellen, dass den folgenden Parameter als String verarbeitet,
 oder ein Typ angegeben in den der folgende Parameter durch einen \inlinecode{System.ComponentModel.TypeConverter} umgewandelt wird,
 und dann ein delegate, dass das Parameter in dem vorher angegebenen Typ verarbeitet.
 Des weiteren werden Boolean flags unterstützt die durch \inlinecode{-OptionsName+} aktiviert
 und durch \inlinecode{-OptiosName-} deaktiviert werden können~\cite{NDeskOptionSetDocumentation}.
 Der letzte eigene Release wurde im Oktober 2008 veröffentlicht~\cite{NDeskOptionsLastRelease},
 dann ist die Bibliothek als Mono.Options als Teil des Mono Projekts neuveröffentlicht worden~\cite{MonoOptions1stCommit},
 dass seit 2011 durch Xamarin~Inc. weiterentwickelt wird~\cite{MonoFutureInterview}, welche seit 2016 Teil von Microsoft ist~\cite{MicrosoftBlogAcquireXamarin}.
 Seit dem ist die Popularität der Bibliothek sehr stark gestiegen, sodass es aktuell kanpp 600.000 Downloads auf nuget.org hat~\cite{MonoOptionsNuget}.
 \subsubsection{Command Line Parser Bibliothek}
 Die 2012 veröffentlichte Bibliothek Command Line Parser~\cite{FirstCommandLineParserCommit}
 \footnote{Der Autor selbst schreibt in der readme des Projekts 2005, jedoch habe ich keine Informationen finden können die dies decken, auf eine Anfrage hat der Autor nicht geantwortet}
 hat als erstes das Konzept von Attribut-definierten Kommandozeilenoberflächen im C\#Bereich.
 Sie wird seit der Veröffentlichung aktiv weiteretwickelt, nutzt die möglichkeiten aktueller C\# Versionen.
 Die Bibliothek stellt eine vollständige Hilfefunktion, baumartige Organistaion von Subkommandos, Parameter, Umfangreiche Typkonvertierungen, sowie Kurzformen bereit~\cite{CommandLineParserWiki}.
 Au\ss erdem stellt die Bibliothek dedizierten F\# Support bereit, der jedoch in dieser Arbeit nicht weiter behandelt werden soll.
 Die Bibliothek ist die am weitesten verbreitete Lösung in diesem Gebiet mit inzwischen über 6.000.000 Downloads auf nuget.org~\cite{CommandLineParserNuget}.